---
title: 정렬(Sort)
draft: true
tags:
  - 알고리즘
date: 2024-03-12
---
정렬에 대해 여러 번 공부했지만, 시간이 흐르면서 다 잊어버렸습니다. 다시 공부할 때마다 이해되지 않았던 내용을 다시 복기하는데 오랜 시간이 걸려, 저만의 정렬 자료를 정리해야겠다고 결심했습니다. 

## 들어가기에 앞서

*코드 작성에 필요한 핵심 개념과 원리만 간단히 다루도록 하겠습니다.* (코드는 없습니다)

## 정렬이란?

데이터를 어떤 조건에 따라 일정한 순서가 되도록 배열하는 것입니다. 

일상 생활에서도 정렬이 이뤄집니다. 책장에 책을 시리즈별로 정리한 것을 예로 들 수 있습니다. 물론 시각적으로 보기 좋게 물건을 정리하는 것도 이유지만, **데이터 검색을 효과적으로 하기 위한 것이 가장 큰 이유라고 생각합니다. 모음 순으로 단어가 정렬된 사전에서 단어를 빠르게 찾을 수 있는 것처럼 말입니다.**

## 정렬의 종류

- 버블 정렬(Bubble Sort)
- 선택 정렬(Selection Sort)
- 삽입 정렬(Insertion Sort)
- 합병 정렬(Merge Sort)
- 퀵 정렬(Quick Sort)
- 기수 정렬(Radix Sort)
- ... 

많은 정렬이 있지만 *기수 정렬까지만 다루도록 하겠습니다.* 이 방법들은 결과적으로 똑같은 결괏값을 도출하지만, 각각의 장단점이 존재합니다.

[정렬 알고리즘 속도 체감할 수 있는 사이트](https://www.toptal.com/developers/sorting-algorithms)
==[정렬 과정을 시각적으로 볼 수 있는 사이트](https://visualgo.net/en/sorting)== 
이 사이트 추천합니다! 글보다 빠르게 정렬 과정을 이해할 수 있습니다.
## Easy

먼저 정렬 중 가장 쉬운 편에 속한 버블 정렬, 삽입 정렬, 선택 정렬에 대해 알아보도록 하겠습니다.

### 🌟 버블 정렬(Bubble Sort)

#### 개념
배열에서 인접한 요소 쌍끼리 비교하여 조건에 맞게 정렬하는 방법입니다. **매번 코드를 구현할 때 중첩된 for 문을 어떻게 작성해야 할지 몰라 많이 헤맸습니다.**

#### 구현
==먼저 Inner loop 로직에 대해 생각해보면 쉽게 구현할 수 있습니다!== 오름차순으로 정렬한다고 가정했을 때, 배열의 첫 번째 인덱스부터 차례대로 인접한 요소끼리 비교하고 swap하는 과정을 거치면, 가장 큰 요소가 마지막에 위치하게 됩니다. 이것이 step 1 이고, Inner loop는 각 단계(step)를 담당하는 부분입니다.

![[Pasted image 20240312185339.png]]

step 1 을 거쳤다고 배열의 요소가 모두 정렬되는 것은 아닙니다. **마지막 요소를 제외하고 또 다른 step을 반복해야 비로소 모두 정렬이 됩니다.** Outer loop가 이 역할을 합니다. **Outer loop는 배열의 크기만큼 반복하여, Inner loop가 배열의 모든 값을 정렬할 수 있도록 도와주는 역할을 합니다.**

#### 시간 복잡도
==버블 정렬 최악 시간 복잡도는 O(n^2)==입니다. 데이터가 방대해짐에 따라 비효율적이고 잘 사용하지 않습니다. 

### 🌟 선택 정렬(Selection Sort)

#### 개념
특정한 조건에 해당하는 요소를 찾아, 배열의 처음부터 순서대로 쌓아가며 정렬하는 알고리즘입니다.

#### 구현
==버블 정렬과 마찬가지로 Inner loop 로직을 먼저 생각해보면 쉽게 구현할 수 있습니다.== 오름차순으로 정렬한다고 가정했을 때, **가장 작은 값의 Index 찾는 것이 Inner loop가 하는 역할입니다.** 

**Outer loop는 Inner loop에서 찾은 가장 작은 값의 Index와 제일 처음 요소를 swap하고, 이를 배열의 크기만큼 반복하는 역할을 합니다.**

![[Pasted image 20240314185519.png]]


1 step을 거치면 첫 번째 요소가 정렬 됩니다. step을 반복하면 모든 배열의 요소가 정렬될 것입니다!

#### 시간 복잡도
==선택 정렬의 최악 시간 복잡도는 O(n^2)입니다.== 버블 정렬과 마찬가지로 데이터가 방대해지면 비효율적입니다. 

#### 장점
선택 정렬은 구현하기 쉽고, loop가 끝날 때 swap이 딱 한 번만 이뤄지기 때문에 버블 정렬보다 메모리 측면에서 효율적이라 할 수 있습니다.

### 🌟 삽입 정렬(Insertion Sort)

#### 개념
주어진 데이터 셋을 정렬된 부분과 정렬되지 않은 부분(이 글에선 Left 부분입니다.)으로 나누고, 정렬되지 않은 부분의 원소를 하나씩 적절한 위치에 삽입하면서 정렬하는 알고리즘입니다.
#### 구현
정렬되지 않은 데이터 셋을 삽입 정렬로 정렬하려면 **두 번째 요소부터 시작**해야 합니다. 

![[Pasted image 20240315185444.png]]

==먼저 Inner loop 로직을 생각해봅시다.== 오름차순으로 정렬한다고 가정했을 때, **Inner loop는 사진에서 Pointer 요소와 정렬된 부분(Left)을 비교해 Pointer 요소를 적절한 위치에 삽입하는 역할을 합니다.**

![[Pasted image 20240315193157.png]]

1 step 을 거쳤다고 모든 배열의 요소가 정렬되는 것은 아닙니다. **따라서 Outer loop를 통해 Inner loop를 \[배열의 길이 - 1\] 만큼 반복해 모든 배열의 요소가 정렬되게끔 만들어줍니다.**

#### 시간 복잡도
==삽입 정렬의 최악 시간 복잡도는 O(n^2)입니다.==  버블, 선택 정렬과 마찬가지로 데이터가 방대해지면 비효율적입니다.

#### 장점
삽입 정렬을 새로운 값이 들어오고, 계속 정렬이 필요한 경우에 이점이 있습니다.